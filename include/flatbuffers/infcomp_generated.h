// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INFCOMP_INFCOMP_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_INFCOMP_INFCOMP_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace infcomp {
namespace protocol {

struct Message;

struct NDArray;

struct Beta;

struct Categorical;

struct Discrete;

struct Flip;

struct Gamma;

struct Laplace;

struct MultivariateNormal;

struct Normal;

struct Poisson;

struct UniformContinuous;

struct UniformDiscrete;

struct Sample;

struct Trace;

struct TracesFromPriorRequest;

struct TracesFromPriorReply;

struct ObservesInitRequest;

struct ObservesInitReply;

struct ProposalRequest;

struct ProposalReply;

enum class MessageBody : uint8_t {
  NONE = 0,
  TracesFromPriorRequest = 1,
  ObservesInitRequest = 2,
  ProposalRequest = 3,
  TracesFromPriorReply = 4,
  ObservesInitReply = 5,
  ProposalReply = 6,
  MIN = NONE,
  MAX = ProposalReply
};

inline MessageBody (&EnumValuesMessageBody())[7] {
  static MessageBody values[] = {
    MessageBody::NONE,
    MessageBody::TracesFromPriorRequest,
    MessageBody::ObservesInitRequest,
    MessageBody::ProposalRequest,
    MessageBody::TracesFromPriorReply,
    MessageBody::ObservesInitReply,
    MessageBody::ProposalReply
  };
  return values;
}

inline const char **EnumNamesMessageBody() {
  static const char *names[] = {
    "NONE",
    "TracesFromPriorRequest",
    "ObservesInitRequest",
    "ProposalRequest",
    "TracesFromPriorReply",
    "ObservesInitReply",
    "ProposalReply",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageBody(MessageBody e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageBody()[index];
}

template<typename T> struct MessageBodyTraits {
  static const MessageBody enum_value = MessageBody::NONE;
};

template<> struct MessageBodyTraits<TracesFromPriorRequest> {
  static const MessageBody enum_value = MessageBody::TracesFromPriorRequest;
};

template<> struct MessageBodyTraits<ObservesInitRequest> {
  static const MessageBody enum_value = MessageBody::ObservesInitRequest;
};

template<> struct MessageBodyTraits<ProposalRequest> {
  static const MessageBody enum_value = MessageBody::ProposalRequest;
};

template<> struct MessageBodyTraits<TracesFromPriorReply> {
  static const MessageBody enum_value = MessageBody::TracesFromPriorReply;
};

template<> struct MessageBodyTraits<ObservesInitReply> {
  static const MessageBody enum_value = MessageBody::ObservesInitReply;
};

template<> struct MessageBodyTraits<ProposalReply> {
  static const MessageBody enum_value = MessageBody::ProposalReply;
};

bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type);
bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Distribution : uint8_t {
  NONE = 0,
  Beta = 1,
  Categorical = 2,
  Discrete = 3,
  Flip = 4,
  Gamma = 5,
  Laplace = 6,
  MultivariateNormal = 7,
  Normal = 8,
  Poisson = 9,
  UniformContinuous = 10,
  UniformDiscrete = 11,
  MIN = NONE,
  MAX = UniformDiscrete
};

inline Distribution (&EnumValuesDistribution())[12] {
  static Distribution values[] = {
    Distribution::NONE,
    Distribution::Beta,
    Distribution::Categorical,
    Distribution::Discrete,
    Distribution::Flip,
    Distribution::Gamma,
    Distribution::Laplace,
    Distribution::MultivariateNormal,
    Distribution::Normal,
    Distribution::Poisson,
    Distribution::UniformContinuous,
    Distribution::UniformDiscrete
  };
  return values;
}

inline const char **EnumNamesDistribution() {
  static const char *names[] = {
    "NONE",
    "Beta",
    "Categorical",
    "Discrete",
    "Flip",
    "Gamma",
    "Laplace",
    "MultivariateNormal",
    "Normal",
    "Poisson",
    "UniformContinuous",
    "UniformDiscrete",
    nullptr
  };
  return names;
}

inline const char *EnumNameDistribution(Distribution e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDistribution()[index];
}

template<typename T> struct DistributionTraits {
  static const Distribution enum_value = Distribution::NONE;
};

template<> struct DistributionTraits<Beta> {
  static const Distribution enum_value = Distribution::Beta;
};

template<> struct DistributionTraits<Categorical> {
  static const Distribution enum_value = Distribution::Categorical;
};

template<> struct DistributionTraits<Discrete> {
  static const Distribution enum_value = Distribution::Discrete;
};

template<> struct DistributionTraits<Flip> {
  static const Distribution enum_value = Distribution::Flip;
};

template<> struct DistributionTraits<Gamma> {
  static const Distribution enum_value = Distribution::Gamma;
};

template<> struct DistributionTraits<Laplace> {
  static const Distribution enum_value = Distribution::Laplace;
};

template<> struct DistributionTraits<MultivariateNormal> {
  static const Distribution enum_value = Distribution::MultivariateNormal;
};

template<> struct DistributionTraits<Normal> {
  static const Distribution enum_value = Distribution::Normal;
};

template<> struct DistributionTraits<Poisson> {
  static const Distribution enum_value = Distribution::Poisson;
};

template<> struct DistributionTraits<UniformContinuous> {
  static const Distribution enum_value = Distribution::UniformContinuous;
};

template<> struct DistributionTraits<UniformDiscrete> {
  static const Distribution enum_value = Distribution::UniformDiscrete;
};

bool VerifyDistribution(flatbuffers::Verifier &verifier, const void *obj, Distribution type);
bool VerifyDistributionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BODY_TYPE = 4,
    VT_BODY = 6
  };
  MessageBody body_type() const {
    return static_cast<MessageBody>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const TracesFromPriorRequest *body_as_TracesFromPriorRequest() const {
    return body_type() == MessageBody::TracesFromPriorRequest ? static_cast<const TracesFromPriorRequest *>(body()) : nullptr;
  }
  const ObservesInitRequest *body_as_ObservesInitRequest() const {
    return body_type() == MessageBody::ObservesInitRequest ? static_cast<const ObservesInitRequest *>(body()) : nullptr;
  }
  const ProposalRequest *body_as_ProposalRequest() const {
    return body_type() == MessageBody::ProposalRequest ? static_cast<const ProposalRequest *>(body()) : nullptr;
  }
  const TracesFromPriorReply *body_as_TracesFromPriorReply() const {
    return body_type() == MessageBody::TracesFromPriorReply ? static_cast<const TracesFromPriorReply *>(body()) : nullptr;
  }
  const ObservesInitReply *body_as_ObservesInitReply() const {
    return body_type() == MessageBody::ObservesInitReply ? static_cast<const ObservesInitReply *>(body()) : nullptr;
  }
  const ProposalReply *body_as_ProposalReply() const {
    return body_type() == MessageBody::ProposalReply ? static_cast<const ProposalReply *>(body()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE) &&
           VerifyOffset(verifier, VT_BODY) &&
           VerifyMessageBody(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const TracesFromPriorRequest *Message::body_as<TracesFromPriorRequest>() const {
  return body_as_TracesFromPriorRequest();
}

template<> inline const ObservesInitRequest *Message::body_as<ObservesInitRequest>() const {
  return body_as_ObservesInitRequest();
}

template<> inline const ProposalRequest *Message::body_as<ProposalRequest>() const {
  return body_as_ProposalRequest();
}

template<> inline const TracesFromPriorReply *Message::body_as<TracesFromPriorReply>() const {
  return body_as_TracesFromPriorReply();
}

template<> inline const ObservesInitReply *Message::body_as<ObservesInitReply>() const {
  return body_as_ObservesInitReply();
}

template<> inline const ProposalReply *Message::body_as<ProposalReply>() const {
  return body_as_ProposalReply();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_body_type(MessageBody body_type) {
    fbb_.AddElement<uint8_t>(Message::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(flatbuffers::Offset<void> body) {
    fbb_.AddOffset(Message::VT_BODY, body);
  }
  MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageBody body_type = MessageBody::NONE,
    flatbuffers::Offset<void> body = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

struct NDArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4,
    VT_SHAPE = 6
  };
  const flatbuffers::Vector<double> *data() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DATA);
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.Verify(shape()) &&
           verifier.EndTable();
  }
};

struct NDArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(NDArray::VT_DATA, data);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(NDArray::VT_SHAPE, shape);
  }
  NDArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NDArrayBuilder &operator=(const NDArrayBuilder &);
  flatbuffers::Offset<NDArray> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<NDArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<NDArray> CreateNDArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0) {
  NDArrayBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<NDArray> CreateNDArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *data = nullptr,
    const std::vector<int32_t> *shape = nullptr) {
  return infcomp::protocol::CreateNDArray(
      _fbb,
      data ? _fbb.CreateVector<double>(*data) : 0,
      shape ? _fbb.CreateVector<int32_t>(*shape) : 0);
}

struct Beta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROPOSAL_MODE = 4,
    VT_PROPOSAL_CERTAINTY = 6
  };
  double proposal_mode() const {
    return GetField<double>(VT_PROPOSAL_MODE, 0.0);
  }
  double proposal_certainty() const {
    return GetField<double>(VT_PROPOSAL_CERTAINTY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PROPOSAL_MODE) &&
           VerifyField<double>(verifier, VT_PROPOSAL_CERTAINTY) &&
           verifier.EndTable();
  }
};

struct BetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_proposal_mode(double proposal_mode) {
    fbb_.AddElement<double>(Beta::VT_PROPOSAL_MODE, proposal_mode, 0.0);
  }
  void add_proposal_certainty(double proposal_certainty) {
    fbb_.AddElement<double>(Beta::VT_PROPOSAL_CERTAINTY, proposal_certainty, 0.0);
  }
  BetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BetaBuilder &operator=(const BetaBuilder &);
  flatbuffers::Offset<Beta> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Beta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Beta> CreateBeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    double proposal_mode = 0.0,
    double proposal_certainty = 0.0) {
  BetaBuilder builder_(_fbb);
  builder_.add_proposal_certainty(proposal_certainty);
  builder_.add_proposal_mode(proposal_mode);
  return builder_.Finish();
}

struct Categorical FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRIOR_SIZE = 4,
    VT_PROPOSAL_PROBABILITIES = 6
  };
  int32_t prior_size() const {
    return GetField<int32_t>(VT_PRIOR_SIZE, 0);
  }
  const NDArray *proposal_probabilities() const {
    return GetPointer<const NDArray *>(VT_PROPOSAL_PROBABILITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRIOR_SIZE) &&
           VerifyOffset(verifier, VT_PROPOSAL_PROBABILITIES) &&
           verifier.VerifyTable(proposal_probabilities()) &&
           verifier.EndTable();
  }
};

struct CategoricalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prior_size(int32_t prior_size) {
    fbb_.AddElement<int32_t>(Categorical::VT_PRIOR_SIZE, prior_size, 0);
  }
  void add_proposal_probabilities(flatbuffers::Offset<NDArray> proposal_probabilities) {
    fbb_.AddOffset(Categorical::VT_PROPOSAL_PROBABILITIES, proposal_probabilities);
  }
  CategoricalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CategoricalBuilder &operator=(const CategoricalBuilder &);
  flatbuffers::Offset<Categorical> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Categorical>(end);
    return o;
  }
};

inline flatbuffers::Offset<Categorical> CreateCategorical(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t prior_size = 0,
    flatbuffers::Offset<NDArray> proposal_probabilities = 0) {
  CategoricalBuilder builder_(_fbb);
  builder_.add_proposal_probabilities(proposal_probabilities);
  builder_.add_prior_size(prior_size);
  return builder_.Finish();
}

struct Discrete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRIOR_SIZE = 4,
    VT_PROPOSAL_PROBABILITIES = 6
  };
  int32_t prior_size() const {
    return GetField<int32_t>(VT_PRIOR_SIZE, 0);
  }
  const NDArray *proposal_probabilities() const {
    return GetPointer<const NDArray *>(VT_PROPOSAL_PROBABILITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRIOR_SIZE) &&
           VerifyOffset(verifier, VT_PROPOSAL_PROBABILITIES) &&
           verifier.VerifyTable(proposal_probabilities()) &&
           verifier.EndTable();
  }
};

struct DiscreteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prior_size(int32_t prior_size) {
    fbb_.AddElement<int32_t>(Discrete::VT_PRIOR_SIZE, prior_size, 0);
  }
  void add_proposal_probabilities(flatbuffers::Offset<NDArray> proposal_probabilities) {
    fbb_.AddOffset(Discrete::VT_PROPOSAL_PROBABILITIES, proposal_probabilities);
  }
  DiscreteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscreteBuilder &operator=(const DiscreteBuilder &);
  flatbuffers::Offset<Discrete> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Discrete>(end);
    return o;
  }
};

inline flatbuffers::Offset<Discrete> CreateDiscrete(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t prior_size = 0,
    flatbuffers::Offset<NDArray> proposal_probabilities = 0) {
  DiscreteBuilder builder_(_fbb);
  builder_.add_proposal_probabilities(proposal_probabilities);
  builder_.add_prior_size(prior_size);
  return builder_.Finish();
}

struct Flip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROPOSAL_PROBABILITY = 4
  };
  double proposal_probability() const {
    return GetField<double>(VT_PROPOSAL_PROBABILITY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PROPOSAL_PROBABILITY) &&
           verifier.EndTable();
  }
};

struct FlipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_proposal_probability(double proposal_probability) {
    fbb_.AddElement<double>(Flip::VT_PROPOSAL_PROBABILITY, proposal_probability, 0.0);
  }
  FlipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlipBuilder &operator=(const FlipBuilder &);
  flatbuffers::Offset<Flip> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<Flip>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flip> CreateFlip(
    flatbuffers::FlatBufferBuilder &_fbb,
    double proposal_probability = 0.0) {
  FlipBuilder builder_(_fbb);
  builder_.add_proposal_probability(proposal_probability);
  return builder_.Finish();
}

struct Gamma FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROPOSAL_LOCATION = 4,
    VT_PROPOSAL_SCALE = 6
  };
  double proposal_location() const {
    return GetField<double>(VT_PROPOSAL_LOCATION, 0.0);
  }
  double proposal_scale() const {
    return GetField<double>(VT_PROPOSAL_SCALE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PROPOSAL_LOCATION) &&
           VerifyField<double>(verifier, VT_PROPOSAL_SCALE) &&
           verifier.EndTable();
  }
};

struct GammaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_proposal_location(double proposal_location) {
    fbb_.AddElement<double>(Gamma::VT_PROPOSAL_LOCATION, proposal_location, 0.0);
  }
  void add_proposal_scale(double proposal_scale) {
    fbb_.AddElement<double>(Gamma::VT_PROPOSAL_SCALE, proposal_scale, 0.0);
  }
  GammaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GammaBuilder &operator=(const GammaBuilder &);
  flatbuffers::Offset<Gamma> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Gamma>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gamma> CreateGamma(
    flatbuffers::FlatBufferBuilder &_fbb,
    double proposal_location = 0.0,
    double proposal_scale = 0.0) {
  GammaBuilder builder_(_fbb);
  builder_.add_proposal_scale(proposal_scale);
  builder_.add_proposal_location(proposal_location);
  return builder_.Finish();
}

struct Laplace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRIOR_LOCATION = 4,
    VT_PRIOR_SCALE = 6,
    VT_PROPOSAL_LOCATION = 8,
    VT_PROPOSAL_SCALE = 10
  };
  double prior_location() const {
    return GetField<double>(VT_PRIOR_LOCATION, 0.0);
  }
  double prior_scale() const {
    return GetField<double>(VT_PRIOR_SCALE, 0.0);
  }
  double proposal_location() const {
    return GetField<double>(VT_PROPOSAL_LOCATION, 0.0);
  }
  double proposal_scale() const {
    return GetField<double>(VT_PROPOSAL_SCALE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PRIOR_LOCATION) &&
           VerifyField<double>(verifier, VT_PRIOR_SCALE) &&
           VerifyField<double>(verifier, VT_PROPOSAL_LOCATION) &&
           VerifyField<double>(verifier, VT_PROPOSAL_SCALE) &&
           verifier.EndTable();
  }
};

struct LaplaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prior_location(double prior_location) {
    fbb_.AddElement<double>(Laplace::VT_PRIOR_LOCATION, prior_location, 0.0);
  }
  void add_prior_scale(double prior_scale) {
    fbb_.AddElement<double>(Laplace::VT_PRIOR_SCALE, prior_scale, 0.0);
  }
  void add_proposal_location(double proposal_location) {
    fbb_.AddElement<double>(Laplace::VT_PROPOSAL_LOCATION, proposal_location, 0.0);
  }
  void add_proposal_scale(double proposal_scale) {
    fbb_.AddElement<double>(Laplace::VT_PROPOSAL_SCALE, proposal_scale, 0.0);
  }
  LaplaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaplaceBuilder &operator=(const LaplaceBuilder &);
  flatbuffers::Offset<Laplace> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Laplace>(end);
    return o;
  }
};

inline flatbuffers::Offset<Laplace> CreateLaplace(
    flatbuffers::FlatBufferBuilder &_fbb,
    double prior_location = 0.0,
    double prior_scale = 0.0,
    double proposal_location = 0.0,
    double proposal_scale = 0.0) {
  LaplaceBuilder builder_(_fbb);
  builder_.add_proposal_scale(proposal_scale);
  builder_.add_proposal_location(proposal_location);
  builder_.add_prior_scale(prior_scale);
  builder_.add_prior_location(prior_location);
  return builder_.Finish();
}

struct MultivariateNormal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRIOR_MEAN = 4,
    VT_PRIOR_SIGMA = 6,
    VT_PROPOSAL_MEAN = 8,
    VT_PROPOSAL_SIGMA = 10
  };
  const NDArray *prior_mean() const {
    return GetPointer<const NDArray *>(VT_PRIOR_MEAN);
  }
  const NDArray *prior_sigma() const {
    return GetPointer<const NDArray *>(VT_PRIOR_SIGMA);
  }
  const NDArray *proposal_mean() const {
    return GetPointer<const NDArray *>(VT_PROPOSAL_MEAN);
  }
  const NDArray *proposal_sigma() const {
    return GetPointer<const NDArray *>(VT_PROPOSAL_SIGMA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PRIOR_MEAN) &&
           verifier.VerifyTable(prior_mean()) &&
           VerifyOffset(verifier, VT_PRIOR_SIGMA) &&
           verifier.VerifyTable(prior_sigma()) &&
           VerifyOffset(verifier, VT_PROPOSAL_MEAN) &&
           verifier.VerifyTable(proposal_mean()) &&
           VerifyOffset(verifier, VT_PROPOSAL_SIGMA) &&
           verifier.VerifyTable(proposal_sigma()) &&
           verifier.EndTable();
  }
};

struct MultivariateNormalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prior_mean(flatbuffers::Offset<NDArray> prior_mean) {
    fbb_.AddOffset(MultivariateNormal::VT_PRIOR_MEAN, prior_mean);
  }
  void add_prior_sigma(flatbuffers::Offset<NDArray> prior_sigma) {
    fbb_.AddOffset(MultivariateNormal::VT_PRIOR_SIGMA, prior_sigma);
  }
  void add_proposal_mean(flatbuffers::Offset<NDArray> proposal_mean) {
    fbb_.AddOffset(MultivariateNormal::VT_PROPOSAL_MEAN, proposal_mean);
  }
  void add_proposal_sigma(flatbuffers::Offset<NDArray> proposal_sigma) {
    fbb_.AddOffset(MultivariateNormal::VT_PROPOSAL_SIGMA, proposal_sigma);
  }
  MultivariateNormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MultivariateNormalBuilder &operator=(const MultivariateNormalBuilder &);
  flatbuffers::Offset<MultivariateNormal> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<MultivariateNormal>(end);
    return o;
  }
};

inline flatbuffers::Offset<MultivariateNormal> CreateMultivariateNormal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> prior_mean = 0,
    flatbuffers::Offset<NDArray> prior_sigma = 0,
    flatbuffers::Offset<NDArray> proposal_mean = 0,
    flatbuffers::Offset<NDArray> proposal_sigma = 0) {
  MultivariateNormalBuilder builder_(_fbb);
  builder_.add_proposal_sigma(proposal_sigma);
  builder_.add_proposal_mean(proposal_mean);
  builder_.add_prior_sigma(prior_sigma);
  builder_.add_prior_mean(prior_mean);
  return builder_.Finish();
}

struct Normal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRIOR_MEAN = 4,
    VT_PRIOR_STD = 6,
    VT_PROPOSAL_MEAN = 8,
    VT_PROPOSAL_STD = 10
  };
  double prior_mean() const {
    return GetField<double>(VT_PRIOR_MEAN, 0.0);
  }
  double prior_std() const {
    return GetField<double>(VT_PRIOR_STD, 0.0);
  }
  double proposal_mean() const {
    return GetField<double>(VT_PROPOSAL_MEAN, 0.0);
  }
  double proposal_std() const {
    return GetField<double>(VT_PROPOSAL_STD, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PRIOR_MEAN) &&
           VerifyField<double>(verifier, VT_PRIOR_STD) &&
           VerifyField<double>(verifier, VT_PROPOSAL_MEAN) &&
           VerifyField<double>(verifier, VT_PROPOSAL_STD) &&
           verifier.EndTable();
  }
};

struct NormalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prior_mean(double prior_mean) {
    fbb_.AddElement<double>(Normal::VT_PRIOR_MEAN, prior_mean, 0.0);
  }
  void add_prior_std(double prior_std) {
    fbb_.AddElement<double>(Normal::VT_PRIOR_STD, prior_std, 0.0);
  }
  void add_proposal_mean(double proposal_mean) {
    fbb_.AddElement<double>(Normal::VT_PROPOSAL_MEAN, proposal_mean, 0.0);
  }
  void add_proposal_std(double proposal_std) {
    fbb_.AddElement<double>(Normal::VT_PROPOSAL_STD, proposal_std, 0.0);
  }
  NormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormalBuilder &operator=(const NormalBuilder &);
  flatbuffers::Offset<Normal> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Normal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Normal> CreateNormal(
    flatbuffers::FlatBufferBuilder &_fbb,
    double prior_mean = 0.0,
    double prior_std = 0.0,
    double proposal_mean = 0.0,
    double proposal_std = 0.0) {
  NormalBuilder builder_(_fbb);
  builder_.add_proposal_std(proposal_std);
  builder_.add_proposal_mean(proposal_mean);
  builder_.add_prior_std(prior_std);
  builder_.add_prior_mean(prior_mean);
  return builder_.Finish();
}

struct Poisson FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRIOR_LAMBDA = 4,
    VT_PROPOSAL_LAMBDA = 6
  };
  double prior_lambda() const {
    return GetField<double>(VT_PRIOR_LAMBDA, 0.0);
  }
  double proposal_lambda() const {
    return GetField<double>(VT_PROPOSAL_LAMBDA, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PRIOR_LAMBDA) &&
           VerifyField<double>(verifier, VT_PROPOSAL_LAMBDA) &&
           verifier.EndTable();
  }
};

struct PoissonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prior_lambda(double prior_lambda) {
    fbb_.AddElement<double>(Poisson::VT_PRIOR_LAMBDA, prior_lambda, 0.0);
  }
  void add_proposal_lambda(double proposal_lambda) {
    fbb_.AddElement<double>(Poisson::VT_PROPOSAL_LAMBDA, proposal_lambda, 0.0);
  }
  PoissonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoissonBuilder &operator=(const PoissonBuilder &);
  flatbuffers::Offset<Poisson> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Poisson>(end);
    return o;
  }
};

inline flatbuffers::Offset<Poisson> CreatePoisson(
    flatbuffers::FlatBufferBuilder &_fbb,
    double prior_lambda = 0.0,
    double proposal_lambda = 0.0) {
  PoissonBuilder builder_(_fbb);
  builder_.add_proposal_lambda(proposal_lambda);
  builder_.add_prior_lambda(prior_lambda);
  return builder_.Finish();
}

struct UniformContinuous FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRIOR_MIN = 4,
    VT_PRIOR_MAX = 6,
    VT_PROPOSAL_MODE = 8,
    VT_PROPOSAL_CERTAINTY = 10
  };
  double prior_min() const {
    return GetField<double>(VT_PRIOR_MIN, 0.0);
  }
  double prior_max() const {
    return GetField<double>(VT_PRIOR_MAX, 0.0);
  }
  double proposal_mode() const {
    return GetField<double>(VT_PROPOSAL_MODE, 0.0);
  }
  double proposal_certainty() const {
    return GetField<double>(VT_PROPOSAL_CERTAINTY, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PRIOR_MIN) &&
           VerifyField<double>(verifier, VT_PRIOR_MAX) &&
           VerifyField<double>(verifier, VT_PROPOSAL_MODE) &&
           VerifyField<double>(verifier, VT_PROPOSAL_CERTAINTY) &&
           verifier.EndTable();
  }
};

struct UniformContinuousBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prior_min(double prior_min) {
    fbb_.AddElement<double>(UniformContinuous::VT_PRIOR_MIN, prior_min, 0.0);
  }
  void add_prior_max(double prior_max) {
    fbb_.AddElement<double>(UniformContinuous::VT_PRIOR_MAX, prior_max, 0.0);
  }
  void add_proposal_mode(double proposal_mode) {
    fbb_.AddElement<double>(UniformContinuous::VT_PROPOSAL_MODE, proposal_mode, 0.0);
  }
  void add_proposal_certainty(double proposal_certainty) {
    fbb_.AddElement<double>(UniformContinuous::VT_PROPOSAL_CERTAINTY, proposal_certainty, 0.0);
  }
  UniformContinuousBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniformContinuousBuilder &operator=(const UniformContinuousBuilder &);
  flatbuffers::Offset<UniformContinuous> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<UniformContinuous>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniformContinuous> CreateUniformContinuous(
    flatbuffers::FlatBufferBuilder &_fbb,
    double prior_min = 0.0,
    double prior_max = 0.0,
    double proposal_mode = 0.0,
    double proposal_certainty = 0.0) {
  UniformContinuousBuilder builder_(_fbb);
  builder_.add_proposal_certainty(proposal_certainty);
  builder_.add_proposal_mode(proposal_mode);
  builder_.add_prior_max(prior_max);
  builder_.add_prior_min(prior_min);
  return builder_.Finish();
}

struct UniformDiscrete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PRIOR_MIN = 4,
    VT_PRIOR_SIZE = 6,
    VT_PROPOSAL_PROBABILITIES = 8
  };
  int32_t prior_min() const {
    return GetField<int32_t>(VT_PRIOR_MIN, 0);
  }
  int32_t prior_size() const {
    return GetField<int32_t>(VT_PRIOR_SIZE, 0);
  }
  const NDArray *proposal_probabilities() const {
    return GetPointer<const NDArray *>(VT_PROPOSAL_PROBABILITIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PRIOR_MIN) &&
           VerifyField<int32_t>(verifier, VT_PRIOR_SIZE) &&
           VerifyOffset(verifier, VT_PROPOSAL_PROBABILITIES) &&
           verifier.VerifyTable(proposal_probabilities()) &&
           verifier.EndTable();
  }
};

struct UniformDiscreteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_prior_min(int32_t prior_min) {
    fbb_.AddElement<int32_t>(UniformDiscrete::VT_PRIOR_MIN, prior_min, 0);
  }
  void add_prior_size(int32_t prior_size) {
    fbb_.AddElement<int32_t>(UniformDiscrete::VT_PRIOR_SIZE, prior_size, 0);
  }
  void add_proposal_probabilities(flatbuffers::Offset<NDArray> proposal_probabilities) {
    fbb_.AddOffset(UniformDiscrete::VT_PROPOSAL_PROBABILITIES, proposal_probabilities);
  }
  UniformDiscreteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniformDiscreteBuilder &operator=(const UniformDiscreteBuilder &);
  flatbuffers::Offset<UniformDiscrete> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<UniformDiscrete>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniformDiscrete> CreateUniformDiscrete(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t prior_min = 0,
    int32_t prior_size = 0,
    flatbuffers::Offset<NDArray> proposal_probabilities = 0) {
  UniformDiscreteBuilder builder_(_fbb);
  builder_.add_proposal_probabilities(proposal_probabilities);
  builder_.add_prior_size(prior_size);
  builder_.add_prior_min(prior_min);
  return builder_.Finish();
}

struct Sample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME = 4,
    VT_ADDRESS = 6,
    VT_INSTANCE = 8,
    VT_DISTRIBUTION_TYPE = 10,
    VT_DISTRIBUTION = 12,
    VT_VALUE = 14
  };
  int32_t time() const {
    return GetField<int32_t>(VT_TIME, 0);
  }
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  int32_t instance() const {
    return GetField<int32_t>(VT_INSTANCE, 0);
  }
  Distribution distribution_type() const {
    return static_cast<Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const Beta *distribution_as_Beta() const {
    return distribution_type() == Distribution::Beta ? static_cast<const Beta *>(distribution()) : nullptr;
  }
  const Categorical *distribution_as_Categorical() const {
    return distribution_type() == Distribution::Categorical ? static_cast<const Categorical *>(distribution()) : nullptr;
  }
  const Discrete *distribution_as_Discrete() const {
    return distribution_type() == Distribution::Discrete ? static_cast<const Discrete *>(distribution()) : nullptr;
  }
  const Flip *distribution_as_Flip() const {
    return distribution_type() == Distribution::Flip ? static_cast<const Flip *>(distribution()) : nullptr;
  }
  const Gamma *distribution_as_Gamma() const {
    return distribution_type() == Distribution::Gamma ? static_cast<const Gamma *>(distribution()) : nullptr;
  }
  const Laplace *distribution_as_Laplace() const {
    return distribution_type() == Distribution::Laplace ? static_cast<const Laplace *>(distribution()) : nullptr;
  }
  const MultivariateNormal *distribution_as_MultivariateNormal() const {
    return distribution_type() == Distribution::MultivariateNormal ? static_cast<const MultivariateNormal *>(distribution()) : nullptr;
  }
  const Normal *distribution_as_Normal() const {
    return distribution_type() == Distribution::Normal ? static_cast<const Normal *>(distribution()) : nullptr;
  }
  const Poisson *distribution_as_Poisson() const {
    return distribution_type() == Distribution::Poisson ? static_cast<const Poisson *>(distribution()) : nullptr;
  }
  const UniformContinuous *distribution_as_UniformContinuous() const {
    return distribution_type() == Distribution::UniformContinuous ? static_cast<const UniformContinuous *>(distribution()) : nullptr;
  }
  const UniformDiscrete *distribution_as_UniformDiscrete() const {
    return distribution_type() == Distribution::UniformDiscrete ? static_cast<const UniformDiscrete *>(distribution()) : nullptr;
  }
  const NDArray *value() const {
    return GetPointer<const NDArray *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_TIME) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<int32_t>(verifier, VT_INSTANCE) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

template<> inline const Beta *Sample::distribution_as<Beta>() const {
  return distribution_as_Beta();
}

template<> inline const Categorical *Sample::distribution_as<Categorical>() const {
  return distribution_as_Categorical();
}

template<> inline const Discrete *Sample::distribution_as<Discrete>() const {
  return distribution_as_Discrete();
}

template<> inline const Flip *Sample::distribution_as<Flip>() const {
  return distribution_as_Flip();
}

template<> inline const Gamma *Sample::distribution_as<Gamma>() const {
  return distribution_as_Gamma();
}

template<> inline const Laplace *Sample::distribution_as<Laplace>() const {
  return distribution_as_Laplace();
}

template<> inline const MultivariateNormal *Sample::distribution_as<MultivariateNormal>() const {
  return distribution_as_MultivariateNormal();
}

template<> inline const Normal *Sample::distribution_as<Normal>() const {
  return distribution_as_Normal();
}

template<> inline const Poisson *Sample::distribution_as<Poisson>() const {
  return distribution_as_Poisson();
}

template<> inline const UniformContinuous *Sample::distribution_as<UniformContinuous>() const {
  return distribution_as_UniformContinuous();
}

template<> inline const UniformDiscrete *Sample::distribution_as<UniformDiscrete>() const {
  return distribution_as_UniformDiscrete();
}

struct SampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time(int32_t time) {
    fbb_.AddElement<int32_t>(Sample::VT_TIME, time, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Sample::VT_ADDRESS, address);
  }
  void add_instance(int32_t instance) {
    fbb_.AddElement<int32_t>(Sample::VT_INSTANCE, instance, 0);
  }
  void add_distribution_type(Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(Sample::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(Sample::VT_DISTRIBUTION, distribution);
  }
  void add_value(flatbuffers::Offset<NDArray> value) {
    fbb_.AddOffset(Sample::VT_VALUE, value);
  }
  SampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SampleBuilder &operator=(const SampleBuilder &);
  flatbuffers::Offset<Sample> Finish() {
    const auto end = fbb_.EndTable(start_, 6);
    auto o = flatbuffers::Offset<Sample>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sample> CreateSample(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t time = 0,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    int32_t instance = 0,
    Distribution distribution_type = Distribution::NONE,
    flatbuffers::Offset<void> distribution = 0,
    flatbuffers::Offset<NDArray> value = 0) {
  SampleBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_distribution(distribution);
  builder_.add_instance(instance);
  builder_.add_address(address);
  builder_.add_time(time);
  builder_.add_distribution_type(distribution_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sample> CreateSampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t time = 0,
    const char *address = nullptr,
    int32_t instance = 0,
    Distribution distribution_type = Distribution::NONE,
    flatbuffers::Offset<void> distribution = 0,
    flatbuffers::Offset<NDArray> value = 0) {
  return infcomp::protocol::CreateSample(
      _fbb,
      time,
      address ? _fbb.CreateString(address) : 0,
      instance,
      distribution_type,
      distribution,
      value);
}

struct Trace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBSERVES = 4,
    VT_SAMPLES = 6
  };
  const NDArray *observes() const {
    return GetPointer<const NDArray *>(VT_OBSERVES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Sample>> *samples() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sample>> *>(VT_SAMPLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBSERVES) &&
           verifier.VerifyTable(observes()) &&
           VerifyOffset(verifier, VT_SAMPLES) &&
           verifier.Verify(samples()) &&
           verifier.VerifyVectorOfTables(samples()) &&
           verifier.EndTable();
  }
};

struct TraceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_observes(flatbuffers::Offset<NDArray> observes) {
    fbb_.AddOffset(Trace::VT_OBSERVES, observes);
  }
  void add_samples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sample>>> samples) {
    fbb_.AddOffset(Trace::VT_SAMPLES, samples);
  }
  TraceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TraceBuilder &operator=(const TraceBuilder &);
  flatbuffers::Offset<Trace> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Trace>(end);
    return o;
  }
};

inline flatbuffers::Offset<Trace> CreateTrace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> observes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sample>>> samples = 0) {
  TraceBuilder builder_(_fbb);
  builder_.add_samples(samples);
  builder_.add_observes(observes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Trace> CreateTraceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> observes = 0,
    const std::vector<flatbuffers::Offset<Sample>> *samples = nullptr) {
  return infcomp::protocol::CreateTrace(
      _fbb,
      observes,
      samples ? _fbb.CreateVector<flatbuffers::Offset<Sample>>(*samples) : 0);
}

struct TracesFromPriorRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUM_TRACES = 4
  };
  int32_t num_traces() const {
    return GetField<int32_t>(VT_NUM_TRACES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_TRACES) &&
           verifier.EndTable();
  }
};

struct TracesFromPriorRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_traces(int32_t num_traces) {
    fbb_.AddElement<int32_t>(TracesFromPriorRequest::VT_NUM_TRACES, num_traces, 0);
  }
  TracesFromPriorRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TracesFromPriorRequestBuilder &operator=(const TracesFromPriorRequestBuilder &);
  flatbuffers::Offset<TracesFromPriorRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<TracesFromPriorRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<TracesFromPriorRequest> CreateTracesFromPriorRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_traces = 0) {
  TracesFromPriorRequestBuilder builder_(_fbb);
  builder_.add_num_traces(num_traces);
  return builder_.Finish();
}

struct TracesFromPriorReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRACES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Trace>> *traces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Trace>> *>(VT_TRACES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACES) &&
           verifier.Verify(traces()) &&
           verifier.VerifyVectorOfTables(traces()) &&
           verifier.EndTable();
  }
};

struct TracesFromPriorReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_traces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Trace>>> traces) {
    fbb_.AddOffset(TracesFromPriorReply::VT_TRACES, traces);
  }
  TracesFromPriorReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TracesFromPriorReplyBuilder &operator=(const TracesFromPriorReplyBuilder &);
  flatbuffers::Offset<TracesFromPriorReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<TracesFromPriorReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<TracesFromPriorReply> CreateTracesFromPriorReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Trace>>> traces = 0) {
  TracesFromPriorReplyBuilder builder_(_fbb);
  builder_.add_traces(traces);
  return builder_.Finish();
}

inline flatbuffers::Offset<TracesFromPriorReply> CreateTracesFromPriorReplyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Trace>> *traces = nullptr) {
  return infcomp::protocol::CreateTracesFromPriorReply(
      _fbb,
      traces ? _fbb.CreateVector<flatbuffers::Offset<Trace>>(*traces) : 0);
}

struct ObservesInitRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBSERVES = 4
  };
  const NDArray *observes() const {
    return GetPointer<const NDArray *>(VT_OBSERVES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBSERVES) &&
           verifier.VerifyTable(observes()) &&
           verifier.EndTable();
  }
};

struct ObservesInitRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_observes(flatbuffers::Offset<NDArray> observes) {
    fbb_.AddOffset(ObservesInitRequest::VT_OBSERVES, observes);
  }
  ObservesInitRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObservesInitRequestBuilder &operator=(const ObservesInitRequestBuilder &);
  flatbuffers::Offset<ObservesInitRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ObservesInitRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObservesInitRequest> CreateObservesInitRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> observes = 0) {
  ObservesInitRequestBuilder builder_(_fbb);
  builder_.add_observes(observes);
  return builder_.Finish();
}

struct ObservesInitReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUCCESS = 4
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           verifier.EndTable();
  }
};

struct ObservesInitReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ObservesInitReply::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  ObservesInitReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObservesInitReplyBuilder &operator=(const ObservesInitReplyBuilder &);
  flatbuffers::Offset<ObservesInitReply> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ObservesInitReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObservesInitReply> CreateObservesInitReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false) {
  ObservesInitReplyBuilder builder_(_fbb);
  builder_.add_success(success);
  return builder_.Finish();
}

struct ProposalRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENT_SAMPLE = 4,
    VT_PREVIOUS_SAMPLE = 6
  };
  const Sample *current_sample() const {
    return GetPointer<const Sample *>(VT_CURRENT_SAMPLE);
  }
  const Sample *previous_sample() const {
    return GetPointer<const Sample *>(VT_PREVIOUS_SAMPLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURRENT_SAMPLE) &&
           verifier.VerifyTable(current_sample()) &&
           VerifyOffset(verifier, VT_PREVIOUS_SAMPLE) &&
           verifier.VerifyTable(previous_sample()) &&
           verifier.EndTable();
  }
};

struct ProposalRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_current_sample(flatbuffers::Offset<Sample> current_sample) {
    fbb_.AddOffset(ProposalRequest::VT_CURRENT_SAMPLE, current_sample);
  }
  void add_previous_sample(flatbuffers::Offset<Sample> previous_sample) {
    fbb_.AddOffset(ProposalRequest::VT_PREVIOUS_SAMPLE, previous_sample);
  }
  ProposalRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalRequestBuilder &operator=(const ProposalRequestBuilder &);
  flatbuffers::Offset<ProposalRequest> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ProposalRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProposalRequest> CreateProposalRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Sample> current_sample = 0,
    flatbuffers::Offset<Sample> previous_sample = 0) {
  ProposalRequestBuilder builder_(_fbb);
  builder_.add_previous_sample(previous_sample);
  builder_.add_current_sample(current_sample);
  return builder_.Finish();
}

struct ProposalReply FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUCCESS = 4,
    VT_DISTRIBUTION_TYPE = 6,
    VT_DISTRIBUTION = 8
  };
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  Distribution distribution_type() const {
    return static_cast<Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const Beta *distribution_as_Beta() const {
    return distribution_type() == Distribution::Beta ? static_cast<const Beta *>(distribution()) : nullptr;
  }
  const Categorical *distribution_as_Categorical() const {
    return distribution_type() == Distribution::Categorical ? static_cast<const Categorical *>(distribution()) : nullptr;
  }
  const Discrete *distribution_as_Discrete() const {
    return distribution_type() == Distribution::Discrete ? static_cast<const Discrete *>(distribution()) : nullptr;
  }
  const Flip *distribution_as_Flip() const {
    return distribution_type() == Distribution::Flip ? static_cast<const Flip *>(distribution()) : nullptr;
  }
  const Gamma *distribution_as_Gamma() const {
    return distribution_type() == Distribution::Gamma ? static_cast<const Gamma *>(distribution()) : nullptr;
  }
  const Laplace *distribution_as_Laplace() const {
    return distribution_type() == Distribution::Laplace ? static_cast<const Laplace *>(distribution()) : nullptr;
  }
  const MultivariateNormal *distribution_as_MultivariateNormal() const {
    return distribution_type() == Distribution::MultivariateNormal ? static_cast<const MultivariateNormal *>(distribution()) : nullptr;
  }
  const Normal *distribution_as_Normal() const {
    return distribution_type() == Distribution::Normal ? static_cast<const Normal *>(distribution()) : nullptr;
  }
  const Poisson *distribution_as_Poisson() const {
    return distribution_type() == Distribution::Poisson ? static_cast<const Poisson *>(distribution()) : nullptr;
  }
  const UniformContinuous *distribution_as_UniformContinuous() const {
    return distribution_type() == Distribution::UniformContinuous ? static_cast<const UniformContinuous *>(distribution()) : nullptr;
  }
  const UniformDiscrete *distribution_as_UniformDiscrete() const {
    return distribution_type() == Distribution::UniformDiscrete ? static_cast<const UniformDiscrete *>(distribution()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Beta *ProposalReply::distribution_as<Beta>() const {
  return distribution_as_Beta();
}

template<> inline const Categorical *ProposalReply::distribution_as<Categorical>() const {
  return distribution_as_Categorical();
}

template<> inline const Discrete *ProposalReply::distribution_as<Discrete>() const {
  return distribution_as_Discrete();
}

template<> inline const Flip *ProposalReply::distribution_as<Flip>() const {
  return distribution_as_Flip();
}

template<> inline const Gamma *ProposalReply::distribution_as<Gamma>() const {
  return distribution_as_Gamma();
}

template<> inline const Laplace *ProposalReply::distribution_as<Laplace>() const {
  return distribution_as_Laplace();
}

template<> inline const MultivariateNormal *ProposalReply::distribution_as<MultivariateNormal>() const {
  return distribution_as_MultivariateNormal();
}

template<> inline const Normal *ProposalReply::distribution_as<Normal>() const {
  return distribution_as_Normal();
}

template<> inline const Poisson *ProposalReply::distribution_as<Poisson>() const {
  return distribution_as_Poisson();
}

template<> inline const UniformContinuous *ProposalReply::distribution_as<UniformContinuous>() const {
  return distribution_as_UniformContinuous();
}

template<> inline const UniformDiscrete *ProposalReply::distribution_as<UniformDiscrete>() const {
  return distribution_as_UniformDiscrete();
}

struct ProposalReplyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(ProposalReply::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  void add_distribution_type(Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(ProposalReply::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(ProposalReply::VT_DISTRIBUTION, distribution);
  }
  ProposalReplyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalReplyBuilder &operator=(const ProposalReplyBuilder &);
  flatbuffers::Offset<ProposalReply> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<ProposalReply>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProposalReply> CreateProposalReply(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool success = false,
    Distribution distribution_type = Distribution::NONE,
    flatbuffers::Offset<void> distribution = 0) {
  ProposalReplyBuilder builder_(_fbb);
  builder_.add_distribution(distribution);
  builder_.add_distribution_type(distribution_type);
  builder_.add_success(success);
  return builder_.Finish();
}

inline bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type) {
  switch (type) {
    case MessageBody::NONE: {
      return true;
    }
    case MessageBody::TracesFromPriorRequest: {
      auto ptr = reinterpret_cast<const TracesFromPriorRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::ObservesInitRequest: {
      auto ptr = reinterpret_cast<const ObservesInitRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::ProposalRequest: {
      auto ptr = reinterpret_cast<const ProposalRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::TracesFromPriorReply: {
      auto ptr = reinterpret_cast<const TracesFromPriorReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::ObservesInitReply: {
      auto ptr = reinterpret_cast<const ObservesInitReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::ProposalReply: {
      auto ptr = reinterpret_cast<const ProposalReply *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageBody(
        verifier,  values->Get(i), types->GetEnum<MessageBody>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDistribution(flatbuffers::Verifier &verifier, const void *obj, Distribution type) {
  switch (type) {
    case Distribution::NONE: {
      return true;
    }
    case Distribution::Beta: {
      auto ptr = reinterpret_cast<const Beta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Categorical: {
      auto ptr = reinterpret_cast<const Categorical *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Discrete: {
      auto ptr = reinterpret_cast<const Discrete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Flip: {
      auto ptr = reinterpret_cast<const Flip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Gamma: {
      auto ptr = reinterpret_cast<const Gamma *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Laplace: {
      auto ptr = reinterpret_cast<const Laplace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::MultivariateNormal: {
      auto ptr = reinterpret_cast<const MultivariateNormal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Normal: {
      auto ptr = reinterpret_cast<const Normal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Poisson: {
      auto ptr = reinterpret_cast<const Poisson *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::UniformContinuous: {
      auto ptr = reinterpret_cast<const UniformContinuous *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::UniformDiscrete: {
      auto ptr = reinterpret_cast<const UniformDiscrete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyDistributionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDistribution(
        verifier,  values->Get(i), types->GetEnum<Distribution>(i))) {
      return false;
    }
  }
  return true;
}

inline const infcomp::protocol::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<infcomp::protocol::Message>(buf);
}

inline const char *MessageIdentifier() {
  return "INFC";
}

inline bool MessageBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MessageIdentifier());
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<infcomp::protocol::Message>(MessageIdentifier());
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<infcomp::protocol::Message> root) {
  fbb.Finish(root, MessageIdentifier());
}

}  // namespace protocol
}  // namespace infcomp

#endif  // FLATBUFFERS_GENERATED_INFCOMP_INFCOMP_PROTOCOL_H_
