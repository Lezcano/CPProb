// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INFCOMP_PROTOCOL_H_
#define FLATBUFFERS_GENERATED_INFCOMP_PROTOCOL_H_

#include "flatbuffers/flatbuffers.h"

namespace protocol {

struct Message;

struct NDArray;

struct Beta;

struct Discrete;

struct Flip;

struct Gamma;

struct Laplace;

struct TableDistribution;

struct Mixture;

struct ProductDistribution;

struct MultivariateNormal;

struct Normal;

struct Poisson;

struct Truncated;

struct UniformContinuous;

struct UniformDiscrete;

struct Sample;

struct Trace;

struct RequestTraces;

struct ReplyTraces;

struct RequestStartInference;

struct ReplyStartInference;

struct RequestFinishInference;

struct ReplyFinishInference;

struct RequestProposal;

struct ReplyProposal;

enum class MessageBody : uint8_t {
  NONE = 0,
  RequestTraces = 1,
  ReplyTraces = 2,
  RequestStartInference = 3,
  ReplyStartInference = 4,
  RequestFinishInference = 5,
  ReplyFinishInference = 6,
  RequestProposal = 7,
  ReplyProposal = 8,
  MIN = NONE,
  MAX = ReplyProposal
};

inline MessageBody (&EnumValuesMessageBody())[9] {
  static MessageBody values[] = {
    MessageBody::NONE,
    MessageBody::RequestTraces,
    MessageBody::ReplyTraces,
    MessageBody::RequestStartInference,
    MessageBody::ReplyStartInference,
    MessageBody::RequestFinishInference,
    MessageBody::ReplyFinishInference,
    MessageBody::RequestProposal,
    MessageBody::ReplyProposal
  };
  return values;
}

inline const char **EnumNamesMessageBody() {
  static const char *names[] = {
    "NONE",
    "RequestTraces",
    "ReplyTraces",
    "RequestStartInference",
    "ReplyStartInference",
    "RequestFinishInference",
    "ReplyFinishInference",
    "RequestProposal",
    "ReplyProposal",
    nullptr
  };
  return names;
}

inline const char *EnumNameMessageBody(MessageBody e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMessageBody()[index];
}

template<typename T> struct MessageBodyTraits {
  static const MessageBody enum_value = MessageBody::NONE;
};

template<> struct MessageBodyTraits<RequestTraces> {
  static const MessageBody enum_value = MessageBody::RequestTraces;
};

template<> struct MessageBodyTraits<ReplyTraces> {
  static const MessageBody enum_value = MessageBody::ReplyTraces;
};

template<> struct MessageBodyTraits<RequestStartInference> {
  static const MessageBody enum_value = MessageBody::RequestStartInference;
};

template<> struct MessageBodyTraits<ReplyStartInference> {
  static const MessageBody enum_value = MessageBody::ReplyStartInference;
};

template<> struct MessageBodyTraits<RequestFinishInference> {
  static const MessageBody enum_value = MessageBody::RequestFinishInference;
};

template<> struct MessageBodyTraits<ReplyFinishInference> {
  static const MessageBody enum_value = MessageBody::ReplyFinishInference;
};

template<> struct MessageBodyTraits<RequestProposal> {
  static const MessageBody enum_value = MessageBody::RequestProposal;
};

template<> struct MessageBodyTraits<ReplyProposal> {
  static const MessageBody enum_value = MessageBody::ReplyProposal;
};

bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type);
bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class Distribution : uint8_t {
  NONE = 0,
  Beta = 1,
  Discrete = 2,
  Flip = 3,
  Gamma = 4,
  Laplace = 5,
  Mixture = 6,
  MultivariateNormal = 7,
  Normal = 8,
  Poisson = 9,
  Truncated = 10,
  UniformContinuous = 11,
  UniformDiscrete = 12,
  MIN = NONE,
  MAX = UniformDiscrete
};

inline Distribution (&EnumValuesDistribution())[13] {
  static Distribution values[] = {
    Distribution::NONE,
    Distribution::Beta,
    Distribution::Discrete,
    Distribution::Flip,
    Distribution::Gamma,
    Distribution::Laplace,
    Distribution::Mixture,
    Distribution::MultivariateNormal,
    Distribution::Normal,
    Distribution::Poisson,
    Distribution::Truncated,
    Distribution::UniformContinuous,
    Distribution::UniformDiscrete
  };
  return values;
}

inline const char **EnumNamesDistribution() {
  static const char *names[] = {
    "NONE",
    "Beta",
    "Discrete",
    "Flip",
    "Gamma",
    "Laplace",
    "Mixture",
    "MultivariateNormal",
    "Normal",
    "Poisson",
    "Truncated",
    "UniformContinuous",
    "UniformDiscrete",
    nullptr
  };
  return names;
}

inline const char *EnumNameDistribution(Distribution e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesDistribution()[index];
}

template<typename T> struct DistributionTraits {
  static const Distribution enum_value = Distribution::NONE;
};

template<> struct DistributionTraits<Beta> {
  static const Distribution enum_value = Distribution::Beta;
};

template<> struct DistributionTraits<Discrete> {
  static const Distribution enum_value = Distribution::Discrete;
};

template<> struct DistributionTraits<Flip> {
  static const Distribution enum_value = Distribution::Flip;
};

template<> struct DistributionTraits<Gamma> {
  static const Distribution enum_value = Distribution::Gamma;
};

template<> struct DistributionTraits<Laplace> {
  static const Distribution enum_value = Distribution::Laplace;
};

template<> struct DistributionTraits<Mixture> {
  static const Distribution enum_value = Distribution::Mixture;
};

template<> struct DistributionTraits<MultivariateNormal> {
  static const Distribution enum_value = Distribution::MultivariateNormal;
};

template<> struct DistributionTraits<Normal> {
  static const Distribution enum_value = Distribution::Normal;
};

template<> struct DistributionTraits<Poisson> {
  static const Distribution enum_value = Distribution::Poisson;
};

template<> struct DistributionTraits<Truncated> {
  static const Distribution enum_value = Distribution::Truncated;
};

template<> struct DistributionTraits<UniformContinuous> {
  static const Distribution enum_value = Distribution::UniformContinuous;
};

template<> struct DistributionTraits<UniformDiscrete> {
  static const Distribution enum_value = Distribution::UniformDiscrete;
};

bool VerifyDistribution(flatbuffers::Verifier &verifier, const void *obj, Distribution type);
bool VerifyDistributionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BODY_TYPE = 4,
    VT_BODY = 6
  };
  MessageBody body_type() const {
    return static_cast<MessageBody>(GetField<uint8_t>(VT_BODY_TYPE, 0));
  }
  const void *body() const {
    return GetPointer<const void *>(VT_BODY);
  }
  template<typename T> const T *body_as() const;
  const RequestTraces *body_as_RequestTraces() const {
    return body_type() == MessageBody::RequestTraces ? static_cast<const RequestTraces *>(body()) : nullptr;
  }
  const ReplyTraces *body_as_ReplyTraces() const {
    return body_type() == MessageBody::ReplyTraces ? static_cast<const ReplyTraces *>(body()) : nullptr;
  }
  const RequestStartInference *body_as_RequestStartInference() const {
    return body_type() == MessageBody::RequestStartInference ? static_cast<const RequestStartInference *>(body()) : nullptr;
  }
  const ReplyStartInference *body_as_ReplyStartInference() const {
    return body_type() == MessageBody::ReplyStartInference ? static_cast<const ReplyStartInference *>(body()) : nullptr;
  }
  const RequestFinishInference *body_as_RequestFinishInference() const {
    return body_type() == MessageBody::RequestFinishInference ? static_cast<const RequestFinishInference *>(body()) : nullptr;
  }
  const ReplyFinishInference *body_as_ReplyFinishInference() const {
    return body_type() == MessageBody::ReplyFinishInference ? static_cast<const ReplyFinishInference *>(body()) : nullptr;
  }
  const RequestProposal *body_as_RequestProposal() const {
    return body_type() == MessageBody::RequestProposal ? static_cast<const RequestProposal *>(body()) : nullptr;
  }
  const ReplyProposal *body_as_ReplyProposal() const {
    return body_type() == MessageBody::ReplyProposal ? static_cast<const ReplyProposal *>(body()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BODY_TYPE) &&
           VerifyOffset(verifier, VT_BODY) &&
           VerifyMessageBody(verifier, body(), body_type()) &&
           verifier.EndTable();
  }
};

template<> inline const RequestTraces *Message::body_as<RequestTraces>() const {
  return body_as_RequestTraces();
}

template<> inline const ReplyTraces *Message::body_as<ReplyTraces>() const {
  return body_as_ReplyTraces();
}

template<> inline const RequestStartInference *Message::body_as<RequestStartInference>() const {
  return body_as_RequestStartInference();
}

template<> inline const ReplyStartInference *Message::body_as<ReplyStartInference>() const {
  return body_as_ReplyStartInference();
}

template<> inline const RequestFinishInference *Message::body_as<RequestFinishInference>() const {
  return body_as_RequestFinishInference();
}

template<> inline const ReplyFinishInference *Message::body_as<ReplyFinishInference>() const {
  return body_as_ReplyFinishInference();
}

template<> inline const RequestProposal *Message::body_as<RequestProposal>() const {
  return body_as_RequestProposal();
}

template<> inline const ReplyProposal *Message::body_as<ReplyProposal>() const {
  return body_as_ReplyProposal();
}

struct MessageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_body_type(MessageBody body_type) {
    fbb_.AddElement<uint8_t>(Message::VT_BODY_TYPE, static_cast<uint8_t>(body_type), 0);
  }
  void add_body(flatbuffers::Offset<void> body) {
    fbb_.AddOffset(Message::VT_BODY, body);
  }
  MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MessageBuilder &operator=(const MessageBuilder &);
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    MessageBody body_type = MessageBody::NONE,
    flatbuffers::Offset<void> body = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_body(body);
  builder_.add_body_type(body_type);
  return builder_.Finish();
}

struct NDArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4,
    VT_SHAPE = 6
  };
  const flatbuffers::Vector<double> *data() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_DATA);
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.Verify(data()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.Verify(shape()) &&
           verifier.EndTable();
  }
};

struct NDArrayBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<double>> data) {
    fbb_.AddOffset(NDArray::VT_DATA, data);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(NDArray::VT_SHAPE, shape);
  }
  NDArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NDArrayBuilder &operator=(const NDArrayBuilder &);
  flatbuffers::Offset<NDArray> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<NDArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<NDArray> CreateNDArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0) {
  NDArrayBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<NDArray> CreateNDArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *data = nullptr,
    const std::vector<int32_t> *shape = nullptr) {
  return protocol::CreateNDArray(
      _fbb,
      data ? _fbb.CreateVector<double>(*data) : 0,
      shape ? _fbb.CreateVector<int32_t>(*shape) : 0);
}

struct Beta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MODE = 4,
    VT_CERTAINTY = 6,
    VT_VALUE = 8
  };
  double mode() const {
    return GetField<double>(VT_MODE, 0.0);
  }
  double certainty() const {
    return GetField<double>(VT_CERTAINTY, 0.0);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MODE) &&
           VerifyField<double>(verifier, VT_CERTAINTY) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct BetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(double mode) {
    fbb_.AddElement<double>(Beta::VT_MODE, mode, 0.0);
  }
  void add_certainty(double certainty) {
    fbb_.AddElement<double>(Beta::VT_CERTAINTY, certainty, 0.0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Beta::VT_VALUE, value, 0.0);
  }
  BetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BetaBuilder &operator=(const BetaBuilder &);
  flatbuffers::Offset<Beta> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Beta>(end);
    return o;
  }
};

inline flatbuffers::Offset<Beta> CreateBeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    double mode = 0.0,
    double certainty = 0.0,
    double value = 0.0) {
  BetaBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_certainty(certainty);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct Discrete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_PROBABILITIES = 8,
    VT_VALUE = 10
  };
  int32_t min() const {
    return GetField<int32_t>(VT_MIN, 0);
  }
  int32_t max() const {
    return GetField<int32_t>(VT_MAX, 0);
  }
  const flatbuffers::Vector<double> *probabilities() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_PROBABILITIES);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MIN) &&
           VerifyField<int32_t>(verifier, VT_MAX) &&
           VerifyOffset(verifier, VT_PROBABILITIES) &&
           verifier.Verify(probabilities()) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct DiscreteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(int32_t min) {
    fbb_.AddElement<int32_t>(Discrete::VT_MIN, min, 0);
  }
  void add_max(int32_t max) {
    fbb_.AddElement<int32_t>(Discrete::VT_MAX, max, 0);
  }
  void add_probabilities(flatbuffers::Offset<flatbuffers::Vector<double>> probabilities) {
    fbb_.AddOffset(Discrete::VT_PROBABILITIES, probabilities);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Discrete::VT_VALUE, value, 0);
  }
  DiscreteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DiscreteBuilder &operator=(const DiscreteBuilder &);
  flatbuffers::Offset<Discrete> Finish() {
    const auto end = fbb_.EndTable(start_, 4);
    auto o = flatbuffers::Offset<Discrete>(end);
    return o;
  }
};

inline flatbuffers::Offset<Discrete> CreateDiscrete(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min = 0,
    int32_t max = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> probabilities = 0,
    int32_t value = 0) {
  DiscreteBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_probabilities(probabilities);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

inline flatbuffers::Offset<Discrete> CreateDiscreteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min = 0,
    int32_t max = 0,
    const std::vector<double> *probabilities = nullptr,
    int32_t value = 0) {
  return protocol::CreateDiscrete(
      _fbb,
      min,
      max,
      probabilities ? _fbb.CreateVector<double>(*probabilities) : 0,
      value);
}

struct Flip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROBABILITY = 4,
    VT_VALUE = 6
  };
  double probability() const {
    return GetField<double>(VT_PROBABILITY, 0.0);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_PROBABILITY) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct FlipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_probability(double probability) {
    fbb_.AddElement<double>(Flip::VT_PROBABILITY, probability, 0.0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Flip::VT_VALUE, value, 0);
  }
  FlipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlipBuilder &operator=(const FlipBuilder &);
  flatbuffers::Offset<Flip> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Flip>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flip> CreateFlip(
    flatbuffers::FlatBufferBuilder &_fbb,
    double probability = 0.0,
    int32_t value = 0) {
  FlipBuilder builder_(_fbb);
  builder_.add_probability(probability);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Gamma FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHAPE = 4,
    VT_SCALE = 6,
    VT_VALUE = 8
  };
  double shape() const {
    return GetField<double>(VT_SHAPE, 0.0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SHAPE) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct GammaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(double shape) {
    fbb_.AddElement<double>(Gamma::VT_SHAPE, shape, 0.0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(Gamma::VT_SCALE, scale, 0.0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Gamma::VT_VALUE, value, 0.0);
  }
  GammaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GammaBuilder &operator=(const GammaBuilder &);
  flatbuffers::Offset<Gamma> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Gamma>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gamma> CreateGamma(
    flatbuffers::FlatBufferBuilder &_fbb,
    double shape = 0.0,
    double scale = 0.0,
    double value = 0.0) {
  GammaBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_scale(scale);
  builder_.add_shape(shape);
  return builder_.Finish();
}

struct Laplace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MEAN = 4,
    VT_SCALE = 6,
    VT_VALUE = 8
  };
  double mean() const {
    return GetField<double>(VT_MEAN, 0.0);
  }
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MEAN) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct LaplaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mean(double mean) {
    fbb_.AddElement<double>(Laplace::VT_MEAN, mean, 0.0);
  }
  void add_scale(double scale) {
    fbb_.AddElement<double>(Laplace::VT_SCALE, scale, 0.0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Laplace::VT_VALUE, value, 0.0);
  }
  LaplaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LaplaceBuilder &operator=(const LaplaceBuilder &);
  flatbuffers::Offset<Laplace> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Laplace>(end);
    return o;
  }
};

inline flatbuffers::Offset<Laplace> CreateLaplace(
    flatbuffers::FlatBufferBuilder &_fbb,
    double mean = 0.0,
    double scale = 0.0,
    double value = 0.0) {
  LaplaceBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_scale(scale);
  builder_.add_mean(mean);
  return builder_.Finish();
}

struct TableDistribution FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DISTRIBUTION_TYPE = 4,
    VT_DISTRIBUTION = 6
  };
  Distribution distribution_type() const {
    return static_cast<Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const Beta *distribution_as_Beta() const {
    return distribution_type() == Distribution::Beta ? static_cast<const Beta *>(distribution()) : nullptr;
  }
  const Discrete *distribution_as_Discrete() const {
    return distribution_type() == Distribution::Discrete ? static_cast<const Discrete *>(distribution()) : nullptr;
  }
  const Flip *distribution_as_Flip() const {
    return distribution_type() == Distribution::Flip ? static_cast<const Flip *>(distribution()) : nullptr;
  }
  const Gamma *distribution_as_Gamma() const {
    return distribution_type() == Distribution::Gamma ? static_cast<const Gamma *>(distribution()) : nullptr;
  }
  const Laplace *distribution_as_Laplace() const {
    return distribution_type() == Distribution::Laplace ? static_cast<const Laplace *>(distribution()) : nullptr;
  }
  const Mixture *distribution_as_Mixture() const {
    return distribution_type() == Distribution::Mixture ? static_cast<const Mixture *>(distribution()) : nullptr;
  }
  const MultivariateNormal *distribution_as_MultivariateNormal() const {
    return distribution_type() == Distribution::MultivariateNormal ? static_cast<const MultivariateNormal *>(distribution()) : nullptr;
  }
  const Normal *distribution_as_Normal() const {
    return distribution_type() == Distribution::Normal ? static_cast<const Normal *>(distribution()) : nullptr;
  }
  const Poisson *distribution_as_Poisson() const {
    return distribution_type() == Distribution::Poisson ? static_cast<const Poisson *>(distribution()) : nullptr;
  }
  const Truncated *distribution_as_Truncated() const {
    return distribution_type() == Distribution::Truncated ? static_cast<const Truncated *>(distribution()) : nullptr;
  }
  const UniformContinuous *distribution_as_UniformContinuous() const {
    return distribution_type() == Distribution::UniformContinuous ? static_cast<const UniformContinuous *>(distribution()) : nullptr;
  }
  const UniformDiscrete *distribution_as_UniformDiscrete() const {
    return distribution_type() == Distribution::UniformDiscrete ? static_cast<const UniformDiscrete *>(distribution()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Beta *TableDistribution::distribution_as<Beta>() const {
  return distribution_as_Beta();
}

template<> inline const Discrete *TableDistribution::distribution_as<Discrete>() const {
  return distribution_as_Discrete();
}

template<> inline const Flip *TableDistribution::distribution_as<Flip>() const {
  return distribution_as_Flip();
}

template<> inline const Gamma *TableDistribution::distribution_as<Gamma>() const {
  return distribution_as_Gamma();
}

template<> inline const Laplace *TableDistribution::distribution_as<Laplace>() const {
  return distribution_as_Laplace();
}

template<> inline const Mixture *TableDistribution::distribution_as<Mixture>() const {
  return distribution_as_Mixture();
}

template<> inline const MultivariateNormal *TableDistribution::distribution_as<MultivariateNormal>() const {
  return distribution_as_MultivariateNormal();
}

template<> inline const Normal *TableDistribution::distribution_as<Normal>() const {
  return distribution_as_Normal();
}

template<> inline const Poisson *TableDistribution::distribution_as<Poisson>() const {
  return distribution_as_Poisson();
}

template<> inline const Truncated *TableDistribution::distribution_as<Truncated>() const {
  return distribution_as_Truncated();
}

template<> inline const UniformContinuous *TableDistribution::distribution_as<UniformContinuous>() const {
  return distribution_as_UniformContinuous();
}

template<> inline const UniformDiscrete *TableDistribution::distribution_as<UniformDiscrete>() const {
  return distribution_as_UniformDiscrete();
}

struct TableDistributionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_distribution_type(Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(TableDistribution::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(TableDistribution::VT_DISTRIBUTION, distribution);
  }
  TableDistributionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TableDistributionBuilder &operator=(const TableDistributionBuilder &);
  flatbuffers::Offset<TableDistribution> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<TableDistribution>(end);
    return o;
  }
};

inline flatbuffers::Offset<TableDistribution> CreateTableDistribution(
    flatbuffers::FlatBufferBuilder &_fbb,
    Distribution distribution_type = Distribution::NONE,
    flatbuffers::Offset<void> distribution = 0) {
  TableDistributionBuilder builder_(_fbb);
  builder_.add_distribution(distribution);
  builder_.add_distribution_type(distribution_type);
  return builder_.Finish();
}

struct Mixture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COEFFICIENTS = 4,
    VT_DISTRIBUTIONS = 6
  };
  const flatbuffers::Vector<double> *coefficients() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COEFFICIENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<TableDistribution>> *distributions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TableDistribution>> *>(VT_DISTRIBUTIONS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COEFFICIENTS) &&
           verifier.Verify(coefficients()) &&
           VerifyOffset(verifier, VT_DISTRIBUTIONS) &&
           verifier.Verify(distributions()) &&
           verifier.VerifyVectorOfTables(distributions()) &&
           verifier.EndTable();
  }
};

struct MixtureBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_coefficients(flatbuffers::Offset<flatbuffers::Vector<double>> coefficients) {
    fbb_.AddOffset(Mixture::VT_COEFFICIENTS, coefficients);
  }
  void add_distributions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TableDistribution>>> distributions) {
    fbb_.AddOffset(Mixture::VT_DISTRIBUTIONS, distributions);
  }
  MixtureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MixtureBuilder &operator=(const MixtureBuilder &);
  flatbuffers::Offset<Mixture> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Mixture>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mixture> CreateMixture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<double>> coefficients = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TableDistribution>>> distributions = 0) {
  MixtureBuilder builder_(_fbb);
  builder_.add_distributions(distributions);
  builder_.add_coefficients(coefficients);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mixture> CreateMixtureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<double> *coefficients = nullptr,
    const std::vector<flatbuffers::Offset<TableDistribution>> *distributions = nullptr) {
  return protocol::CreateMixture(
      _fbb,
      coefficients ? _fbb.CreateVector<double>(*coefficients) : 0,
      distributions ? _fbb.CreateVector<flatbuffers::Offset<TableDistribution>>(*distributions) : 0);
}

struct ProductDistribution FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DISTRIBUTIONS = 4,
    VT_SHAPE = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<TableDistribution>> *distributions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TableDistribution>> *>(VT_DISTRIBUTIONS);
  }
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DISTRIBUTIONS) &&
           verifier.Verify(distributions()) &&
           verifier.VerifyVectorOfTables(distributions()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.Verify(shape()) &&
           verifier.EndTable();
  }
};

struct ProductDistributionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_distributions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TableDistribution>>> distributions) {
    fbb_.AddOffset(ProductDistribution::VT_DISTRIBUTIONS, distributions);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(ProductDistribution::VT_SHAPE, shape);
  }
  ProductDistributionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProductDistributionBuilder &operator=(const ProductDistributionBuilder &);
  flatbuffers::Offset<ProductDistribution> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ProductDistribution>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProductDistribution> CreateProductDistribution(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TableDistribution>>> distributions = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0) {
  ProductDistributionBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_distributions(distributions);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProductDistribution> CreateProductDistributionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TableDistribution>> *distributions = nullptr,
    const std::vector<int32_t> *shape = nullptr) {
  return protocol::CreateProductDistribution(
      _fbb,
      distributions ? _fbb.CreateVector<flatbuffers::Offset<TableDistribution>>(*distributions) : 0,
      shape ? _fbb.CreateVector<int32_t>(*shape) : 0);
}

struct MultivariateNormal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MEAN = 4,
    VT_COVARIANCE = 6,
    VT_VALUE = 8
  };
  const NDArray *mean() const {
    return GetPointer<const NDArray *>(VT_MEAN);
  }
  const flatbuffers::Vector<double> *covariance() const {
    return GetPointer<const flatbuffers::Vector<double> *>(VT_COVARIANCE);
  }
  const NDArray *value() const {
    return GetPointer<const NDArray *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MEAN) &&
           verifier.VerifyTable(mean()) &&
           VerifyOffset(verifier, VT_COVARIANCE) &&
           verifier.Verify(covariance()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyTable(value()) &&
           verifier.EndTable();
  }
};

struct MultivariateNormalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mean(flatbuffers::Offset<NDArray> mean) {
    fbb_.AddOffset(MultivariateNormal::VT_MEAN, mean);
  }
  void add_covariance(flatbuffers::Offset<flatbuffers::Vector<double>> covariance) {
    fbb_.AddOffset(MultivariateNormal::VT_COVARIANCE, covariance);
  }
  void add_value(flatbuffers::Offset<NDArray> value) {
    fbb_.AddOffset(MultivariateNormal::VT_VALUE, value);
  }
  MultivariateNormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MultivariateNormalBuilder &operator=(const MultivariateNormalBuilder &);
  flatbuffers::Offset<MultivariateNormal> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<MultivariateNormal>(end);
    return o;
  }
};

inline flatbuffers::Offset<MultivariateNormal> CreateMultivariateNormal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> mean = 0,
    flatbuffers::Offset<flatbuffers::Vector<double>> covariance = 0,
    flatbuffers::Offset<NDArray> value = 0) {
  MultivariateNormalBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_covariance(covariance);
  builder_.add_mean(mean);
  return builder_.Finish();
}

inline flatbuffers::Offset<MultivariateNormal> CreateMultivariateNormalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> mean = 0,
    const std::vector<double> *covariance = nullptr,
    flatbuffers::Offset<NDArray> value = 0) {
  return protocol::CreateMultivariateNormal(
      _fbb,
      mean,
      covariance ? _fbb.CreateVector<double>(*covariance) : 0,
      value);
}

struct Normal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MEAN = 4,
    VT_STD = 6,
    VT_VALUE = 8
  };
  double mean() const {
    return GetField<double>(VT_MEAN, 0.0);
  }
  double std() const {
    return GetField<double>(VT_STD, 0.0);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MEAN) &&
           VerifyField<double>(verifier, VT_STD) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct NormalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mean(double mean) {
    fbb_.AddElement<double>(Normal::VT_MEAN, mean, 0.0);
  }
  void add_std(double std) {
    fbb_.AddElement<double>(Normal::VT_STD, std, 0.0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(Normal::VT_VALUE, value, 0.0);
  }
  NormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NormalBuilder &operator=(const NormalBuilder &);
  flatbuffers::Offset<Normal> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Normal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Normal> CreateNormal(
    flatbuffers::FlatBufferBuilder &_fbb,
    double mean = 0.0,
    double std = 0.0,
    double value = 0.0) {
  NormalBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_std(std);
  builder_.add_mean(mean);
  return builder_.Finish();
}

struct Poisson FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MEAN = 4,
    VT_VALUE = 6
  };
  double mean() const {
    return GetField<double>(VT_MEAN, 0.0);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MEAN) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct PoissonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mean(double mean) {
    fbb_.AddElement<double>(Poisson::VT_MEAN, mean, 0.0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(Poisson::VT_VALUE, value, 0);
  }
  PoissonBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoissonBuilder &operator=(const PoissonBuilder &);
  flatbuffers::Offset<Poisson> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Poisson>(end);
    return o;
  }
};

inline flatbuffers::Offset<Poisson> CreatePoisson(
    flatbuffers::FlatBufferBuilder &_fbb,
    double mean = 0.0,
    int32_t value = 0) {
  PoissonBuilder builder_(_fbb);
  builder_.add_mean(mean);
  builder_.add_value(value);
  return builder_.Finish();
}

struct Truncated FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_DISTRIBUTION = 8
  };
  double min() const {
    return GetField<double>(VT_MIN, 0.0);
  }
  double max() const {
    return GetField<double>(VT_MAX, 0.0);
  }
  const TableDistribution *distribution() const {
    return GetPointer<const TableDistribution *>(VT_DISTRIBUTION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MIN) &&
           VerifyField<double>(verifier, VT_MAX) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           verifier.VerifyTable(distribution()) &&
           verifier.EndTable();
  }
};

struct TruncatedBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(double min) {
    fbb_.AddElement<double>(Truncated::VT_MIN, min, 0.0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(Truncated::VT_MAX, max, 0.0);
  }
  void add_distribution(flatbuffers::Offset<TableDistribution> distribution) {
    fbb_.AddOffset(Truncated::VT_DISTRIBUTION, distribution);
  }
  TruncatedBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TruncatedBuilder &operator=(const TruncatedBuilder &);
  flatbuffers::Offset<Truncated> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Truncated>(end);
    return o;
  }
};

inline flatbuffers::Offset<Truncated> CreateTruncated(
    flatbuffers::FlatBufferBuilder &_fbb,
    double min = 0.0,
    double max = 0.0,
    flatbuffers::Offset<TableDistribution> distribution = 0) {
  TruncatedBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_distribution(distribution);
  return builder_.Finish();
}

struct UniformContinuous FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_VALUE = 8
  };
  double min() const {
    return GetField<double>(VT_MIN, 0.0);
  }
  double max() const {
    return GetField<double>(VT_MAX, 0.0);
  }
  double value() const {
    return GetField<double>(VT_VALUE, 0.0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_MIN) &&
           VerifyField<double>(verifier, VT_MAX) &&
           VerifyField<double>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UniformContinuousBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(double min) {
    fbb_.AddElement<double>(UniformContinuous::VT_MIN, min, 0.0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(UniformContinuous::VT_MAX, max, 0.0);
  }
  void add_value(double value) {
    fbb_.AddElement<double>(UniformContinuous::VT_VALUE, value, 0.0);
  }
  UniformContinuousBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniformContinuousBuilder &operator=(const UniformContinuousBuilder &);
  flatbuffers::Offset<UniformContinuous> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<UniformContinuous>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniformContinuous> CreateUniformContinuous(
    flatbuffers::FlatBufferBuilder &_fbb,
    double min = 0.0,
    double max = 0.0,
    double value = 0.0) {
  UniformContinuousBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

struct UniformDiscrete FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_VALUE = 8
  };
  int32_t min() const {
    return GetField<int32_t>(VT_MIN, 0);
  }
  int32_t max() const {
    return GetField<int32_t>(VT_MAX, 0);
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_MIN) &&
           VerifyField<int32_t>(verifier, VT_MAX) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct UniformDiscreteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(int32_t min) {
    fbb_.AddElement<int32_t>(UniformDiscrete::VT_MIN, min, 0);
  }
  void add_max(int32_t max) {
    fbb_.AddElement<int32_t>(UniformDiscrete::VT_MAX, max, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(UniformDiscrete::VT_VALUE, value, 0);
  }
  UniformDiscreteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniformDiscreteBuilder &operator=(const UniformDiscreteBuilder &);
  flatbuffers::Offset<UniformDiscrete> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<UniformDiscrete>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniformDiscrete> CreateUniformDiscrete(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t min = 0,
    int32_t max = 0,
    int32_t value = 0) {
  UniformDiscreteBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_max(max);
  builder_.add_min(min);
  return builder_.Finish();
}

struct Sample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ADDRESS = 4,
    VT_DISTRIBUTION_TYPE = 6,
    VT_DISTRIBUTION = 8
  };
  const flatbuffers::String *address() const {
    return GetPointer<const flatbuffers::String *>(VT_ADDRESS);
  }
  Distribution distribution_type() const {
    return static_cast<Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const Beta *distribution_as_Beta() const {
    return distribution_type() == Distribution::Beta ? static_cast<const Beta *>(distribution()) : nullptr;
  }
  const Discrete *distribution_as_Discrete() const {
    return distribution_type() == Distribution::Discrete ? static_cast<const Discrete *>(distribution()) : nullptr;
  }
  const Flip *distribution_as_Flip() const {
    return distribution_type() == Distribution::Flip ? static_cast<const Flip *>(distribution()) : nullptr;
  }
  const Gamma *distribution_as_Gamma() const {
    return distribution_type() == Distribution::Gamma ? static_cast<const Gamma *>(distribution()) : nullptr;
  }
  const Laplace *distribution_as_Laplace() const {
    return distribution_type() == Distribution::Laplace ? static_cast<const Laplace *>(distribution()) : nullptr;
  }
  const Mixture *distribution_as_Mixture() const {
    return distribution_type() == Distribution::Mixture ? static_cast<const Mixture *>(distribution()) : nullptr;
  }
  const MultivariateNormal *distribution_as_MultivariateNormal() const {
    return distribution_type() == Distribution::MultivariateNormal ? static_cast<const MultivariateNormal *>(distribution()) : nullptr;
  }
  const Normal *distribution_as_Normal() const {
    return distribution_type() == Distribution::Normal ? static_cast<const Normal *>(distribution()) : nullptr;
  }
  const Poisson *distribution_as_Poisson() const {
    return distribution_type() == Distribution::Poisson ? static_cast<const Poisson *>(distribution()) : nullptr;
  }
  const Truncated *distribution_as_Truncated() const {
    return distribution_type() == Distribution::Truncated ? static_cast<const Truncated *>(distribution()) : nullptr;
  }
  const UniformContinuous *distribution_as_UniformContinuous() const {
    return distribution_type() == Distribution::UniformContinuous ? static_cast<const UniformContinuous *>(distribution()) : nullptr;
  }
  const UniformDiscrete *distribution_as_UniformDiscrete() const {
    return distribution_type() == Distribution::UniformDiscrete ? static_cast<const UniformDiscrete *>(distribution()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.Verify(address()) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Beta *Sample::distribution_as<Beta>() const {
  return distribution_as_Beta();
}

template<> inline const Discrete *Sample::distribution_as<Discrete>() const {
  return distribution_as_Discrete();
}

template<> inline const Flip *Sample::distribution_as<Flip>() const {
  return distribution_as_Flip();
}

template<> inline const Gamma *Sample::distribution_as<Gamma>() const {
  return distribution_as_Gamma();
}

template<> inline const Laplace *Sample::distribution_as<Laplace>() const {
  return distribution_as_Laplace();
}

template<> inline const Mixture *Sample::distribution_as<Mixture>() const {
  return distribution_as_Mixture();
}

template<> inline const MultivariateNormal *Sample::distribution_as<MultivariateNormal>() const {
  return distribution_as_MultivariateNormal();
}

template<> inline const Normal *Sample::distribution_as<Normal>() const {
  return distribution_as_Normal();
}

template<> inline const Poisson *Sample::distribution_as<Poisson>() const {
  return distribution_as_Poisson();
}

template<> inline const Truncated *Sample::distribution_as<Truncated>() const {
  return distribution_as_Truncated();
}

template<> inline const UniformContinuous *Sample::distribution_as<UniformContinuous>() const {
  return distribution_as_UniformContinuous();
}

template<> inline const UniformDiscrete *Sample::distribution_as<UniformDiscrete>() const {
  return distribution_as_UniformDiscrete();
}

struct SampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(flatbuffers::Offset<flatbuffers::String> address) {
    fbb_.AddOffset(Sample::VT_ADDRESS, address);
  }
  void add_distribution_type(Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(Sample::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(Sample::VT_DISTRIBUTION, distribution);
  }
  SampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SampleBuilder &operator=(const SampleBuilder &);
  flatbuffers::Offset<Sample> Finish() {
    const auto end = fbb_.EndTable(start_, 3);
    auto o = flatbuffers::Offset<Sample>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sample> CreateSample(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> address = 0,
    Distribution distribution_type = Distribution::NONE,
    flatbuffers::Offset<void> distribution = 0) {
  SampleBuilder builder_(_fbb);
  builder_.add_distribution(distribution);
  builder_.add_address(address);
  builder_.add_distribution_type(distribution_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sample> CreateSampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *address = nullptr,
    Distribution distribution_type = Distribution::NONE,
    flatbuffers::Offset<void> distribution = 0) {
  return protocol::CreateSample(
      _fbb,
      address ? _fbb.CreateString(address) : 0,
      distribution_type,
      distribution);
}

struct Trace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBSERVE = 4,
    VT_SAMPLES = 6
  };
  const NDArray *observe() const {
    return GetPointer<const NDArray *>(VT_OBSERVE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Sample>> *samples() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Sample>> *>(VT_SAMPLES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBSERVE) &&
           verifier.VerifyTable(observe()) &&
           VerifyOffset(verifier, VT_SAMPLES) &&
           verifier.Verify(samples()) &&
           verifier.VerifyVectorOfTables(samples()) &&
           verifier.EndTable();
  }
};

struct TraceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_observe(flatbuffers::Offset<NDArray> observe) {
    fbb_.AddOffset(Trace::VT_OBSERVE, observe);
  }
  void add_samples(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sample>>> samples) {
    fbb_.AddOffset(Trace::VT_SAMPLES, samples);
  }
  TraceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TraceBuilder &operator=(const TraceBuilder &);
  flatbuffers::Offset<Trace> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<Trace>(end);
    return o;
  }
};

inline flatbuffers::Offset<Trace> CreateTrace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> observe = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Sample>>> samples = 0) {
  TraceBuilder builder_(_fbb);
  builder_.add_samples(samples);
  builder_.add_observe(observe);
  return builder_.Finish();
}

inline flatbuffers::Offset<Trace> CreateTraceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> observe = 0,
    const std::vector<flatbuffers::Offset<Sample>> *samples = nullptr) {
  return protocol::CreateTrace(
      _fbb,
      observe,
      samples ? _fbb.CreateVector<flatbuffers::Offset<Sample>>(*samples) : 0);
}

struct RequestTraces FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUM_TRACES = 4
  };
  int32_t num_traces() const {
    return GetField<int32_t>(VT_NUM_TRACES, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_TRACES) &&
           verifier.EndTable();
  }
};

struct RequestTracesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_traces(int32_t num_traces) {
    fbb_.AddElement<int32_t>(RequestTraces::VT_NUM_TRACES, num_traces, 0);
  }
  RequestTracesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestTracesBuilder &operator=(const RequestTracesBuilder &);
  flatbuffers::Offset<RequestTraces> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<RequestTraces>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestTraces> CreateRequestTraces(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_traces = 0) {
  RequestTracesBuilder builder_(_fbb);
  builder_.add_num_traces(num_traces);
  return builder_.Finish();
}

struct ReplyTraces FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRACES = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Trace>> *traces() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Trace>> *>(VT_TRACES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TRACES) &&
           verifier.Verify(traces()) &&
           verifier.VerifyVectorOfTables(traces()) &&
           verifier.EndTable();
  }
};

struct ReplyTracesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_traces(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Trace>>> traces) {
    fbb_.AddOffset(ReplyTraces::VT_TRACES, traces);
  }
  ReplyTracesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReplyTracesBuilder &operator=(const ReplyTracesBuilder &);
  flatbuffers::Offset<ReplyTraces> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<ReplyTraces>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReplyTraces> CreateReplyTraces(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Trace>>> traces = 0) {
  ReplyTracesBuilder builder_(_fbb);
  builder_.add_traces(traces);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReplyTraces> CreateReplyTracesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Trace>> *traces = nullptr) {
  return protocol::CreateReplyTraces(
      _fbb,
      traces ? _fbb.CreateVector<flatbuffers::Offset<Trace>>(*traces) : 0);
}

struct RequestStartInference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OBSERVATION = 4
  };
  const NDArray *observation() const {
    return GetPointer<const NDArray *>(VT_OBSERVATION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OBSERVATION) &&
           verifier.VerifyTable(observation()) &&
           verifier.EndTable();
  }
};

struct RequestStartInferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_observation(flatbuffers::Offset<NDArray> observation) {
    fbb_.AddOffset(RequestStartInference::VT_OBSERVATION, observation);
  }
  RequestStartInferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestStartInferenceBuilder &operator=(const RequestStartInferenceBuilder &);
  flatbuffers::Offset<RequestStartInference> Finish() {
    const auto end = fbb_.EndTable(start_, 1);
    auto o = flatbuffers::Offset<RequestStartInference>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestStartInference> CreateRequestStartInference(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<NDArray> observation = 0) {
  RequestStartInferenceBuilder builder_(_fbb);
  builder_.add_observation(observation);
  return builder_.Finish();
}

struct ReplyStartInference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReplyStartInferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  ReplyStartInferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReplyStartInferenceBuilder &operator=(const ReplyStartInferenceBuilder &);
  flatbuffers::Offset<ReplyStartInference> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<ReplyStartInference>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReplyStartInference> CreateReplyStartInference(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReplyStartInferenceBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RequestFinishInference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RequestFinishInferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  RequestFinishInferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestFinishInferenceBuilder &operator=(const RequestFinishInferenceBuilder &);
  flatbuffers::Offset<RequestFinishInference> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<RequestFinishInference>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestFinishInference> CreateRequestFinishInference(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RequestFinishInferenceBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReplyFinishInference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReplyFinishInferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  ReplyFinishInferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReplyFinishInferenceBuilder &operator=(const ReplyFinishInferenceBuilder &);
  flatbuffers::Offset<ReplyFinishInference> Finish() {
    const auto end = fbb_.EndTable(start_, 0);
    auto o = flatbuffers::Offset<ReplyFinishInference>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReplyFinishInference> CreateReplyFinishInference(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReplyFinishInferenceBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RequestProposal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENT_SAMPLE = 4,
    VT_PREVIOUS_SAMPLE = 6
  };
  const Sample *current_sample() const {
    return GetPointer<const Sample *>(VT_CURRENT_SAMPLE);
  }
  const Sample *previous_sample() const {
    return GetPointer<const Sample *>(VT_PREVIOUS_SAMPLE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CURRENT_SAMPLE) &&
           verifier.VerifyTable(current_sample()) &&
           VerifyOffset(verifier, VT_PREVIOUS_SAMPLE) &&
           verifier.VerifyTable(previous_sample()) &&
           verifier.EndTable();
  }
};

struct RequestProposalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_current_sample(flatbuffers::Offset<Sample> current_sample) {
    fbb_.AddOffset(RequestProposal::VT_CURRENT_SAMPLE, current_sample);
  }
  void add_previous_sample(flatbuffers::Offset<Sample> previous_sample) {
    fbb_.AddOffset(RequestProposal::VT_PREVIOUS_SAMPLE, previous_sample);
  }
  RequestProposalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestProposalBuilder &operator=(const RequestProposalBuilder &);
  flatbuffers::Offset<RequestProposal> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<RequestProposal>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequestProposal> CreateRequestProposal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Sample> current_sample = 0,
    flatbuffers::Offset<Sample> previous_sample = 0) {
  RequestProposalBuilder builder_(_fbb);
  builder_.add_previous_sample(previous_sample);
  builder_.add_current_sample(current_sample);
  return builder_.Finish();
}

struct ReplyProposal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DISTRIBUTION_TYPE = 4,
    VT_DISTRIBUTION = 6
  };
  Distribution distribution_type() const {
    return static_cast<Distribution>(GetField<uint8_t>(VT_DISTRIBUTION_TYPE, 0));
  }
  const void *distribution() const {
    return GetPointer<const void *>(VT_DISTRIBUTION);
  }
  template<typename T> const T *distribution_as() const;
  const Beta *distribution_as_Beta() const {
    return distribution_type() == Distribution::Beta ? static_cast<const Beta *>(distribution()) : nullptr;
  }
  const Discrete *distribution_as_Discrete() const {
    return distribution_type() == Distribution::Discrete ? static_cast<const Discrete *>(distribution()) : nullptr;
  }
  const Flip *distribution_as_Flip() const {
    return distribution_type() == Distribution::Flip ? static_cast<const Flip *>(distribution()) : nullptr;
  }
  const Gamma *distribution_as_Gamma() const {
    return distribution_type() == Distribution::Gamma ? static_cast<const Gamma *>(distribution()) : nullptr;
  }
  const Laplace *distribution_as_Laplace() const {
    return distribution_type() == Distribution::Laplace ? static_cast<const Laplace *>(distribution()) : nullptr;
  }
  const Mixture *distribution_as_Mixture() const {
    return distribution_type() == Distribution::Mixture ? static_cast<const Mixture *>(distribution()) : nullptr;
  }
  const MultivariateNormal *distribution_as_MultivariateNormal() const {
    return distribution_type() == Distribution::MultivariateNormal ? static_cast<const MultivariateNormal *>(distribution()) : nullptr;
  }
  const Normal *distribution_as_Normal() const {
    return distribution_type() == Distribution::Normal ? static_cast<const Normal *>(distribution()) : nullptr;
  }
  const Poisson *distribution_as_Poisson() const {
    return distribution_type() == Distribution::Poisson ? static_cast<const Poisson *>(distribution()) : nullptr;
  }
  const Truncated *distribution_as_Truncated() const {
    return distribution_type() == Distribution::Truncated ? static_cast<const Truncated *>(distribution()) : nullptr;
  }
  const UniformContinuous *distribution_as_UniformContinuous() const {
    return distribution_type() == Distribution::UniformContinuous ? static_cast<const UniformContinuous *>(distribution()) : nullptr;
  }
  const UniformDiscrete *distribution_as_UniformDiscrete() const {
    return distribution_type() == Distribution::UniformDiscrete ? static_cast<const UniformDiscrete *>(distribution()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DISTRIBUTION_TYPE) &&
           VerifyOffset(verifier, VT_DISTRIBUTION) &&
           VerifyDistribution(verifier, distribution(), distribution_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Beta *ReplyProposal::distribution_as<Beta>() const {
  return distribution_as_Beta();
}

template<> inline const Discrete *ReplyProposal::distribution_as<Discrete>() const {
  return distribution_as_Discrete();
}

template<> inline const Flip *ReplyProposal::distribution_as<Flip>() const {
  return distribution_as_Flip();
}

template<> inline const Gamma *ReplyProposal::distribution_as<Gamma>() const {
  return distribution_as_Gamma();
}

template<> inline const Laplace *ReplyProposal::distribution_as<Laplace>() const {
  return distribution_as_Laplace();
}

template<> inline const Mixture *ReplyProposal::distribution_as<Mixture>() const {
  return distribution_as_Mixture();
}

template<> inline const MultivariateNormal *ReplyProposal::distribution_as<MultivariateNormal>() const {
  return distribution_as_MultivariateNormal();
}

template<> inline const Normal *ReplyProposal::distribution_as<Normal>() const {
  return distribution_as_Normal();
}

template<> inline const Poisson *ReplyProposal::distribution_as<Poisson>() const {
  return distribution_as_Poisson();
}

template<> inline const Truncated *ReplyProposal::distribution_as<Truncated>() const {
  return distribution_as_Truncated();
}

template<> inline const UniformContinuous *ReplyProposal::distribution_as<UniformContinuous>() const {
  return distribution_as_UniformContinuous();
}

template<> inline const UniformDiscrete *ReplyProposal::distribution_as<UniformDiscrete>() const {
  return distribution_as_UniformDiscrete();
}

struct ReplyProposalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_distribution_type(Distribution distribution_type) {
    fbb_.AddElement<uint8_t>(ReplyProposal::VT_DISTRIBUTION_TYPE, static_cast<uint8_t>(distribution_type), 0);
  }
  void add_distribution(flatbuffers::Offset<void> distribution) {
    fbb_.AddOffset(ReplyProposal::VT_DISTRIBUTION, distribution);
  }
  ReplyProposalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReplyProposalBuilder &operator=(const ReplyProposalBuilder &);
  flatbuffers::Offset<ReplyProposal> Finish() {
    const auto end = fbb_.EndTable(start_, 2);
    auto o = flatbuffers::Offset<ReplyProposal>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReplyProposal> CreateReplyProposal(
    flatbuffers::FlatBufferBuilder &_fbb,
    Distribution distribution_type = Distribution::NONE,
    flatbuffers::Offset<void> distribution = 0) {
  ReplyProposalBuilder builder_(_fbb);
  builder_.add_distribution(distribution);
  builder_.add_distribution_type(distribution_type);
  return builder_.Finish();
}

inline bool VerifyMessageBody(flatbuffers::Verifier &verifier, const void *obj, MessageBody type) {
  switch (type) {
    case MessageBody::NONE: {
      return true;
    }
    case MessageBody::RequestTraces: {
      auto ptr = reinterpret_cast<const RequestTraces *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::ReplyTraces: {
      auto ptr = reinterpret_cast<const ReplyTraces *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::RequestStartInference: {
      auto ptr = reinterpret_cast<const RequestStartInference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::ReplyStartInference: {
      auto ptr = reinterpret_cast<const ReplyStartInference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::RequestFinishInference: {
      auto ptr = reinterpret_cast<const RequestFinishInference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::ReplyFinishInference: {
      auto ptr = reinterpret_cast<const ReplyFinishInference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::RequestProposal: {
      auto ptr = reinterpret_cast<const RequestProposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case MessageBody::ReplyProposal: {
      auto ptr = reinterpret_cast<const ReplyProposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyMessageBodyVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyMessageBody(
        verifier,  values->Get(i), types->GetEnum<MessageBody>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyDistribution(flatbuffers::Verifier &verifier, const void *obj, Distribution type) {
  switch (type) {
    case Distribution::NONE: {
      return true;
    }
    case Distribution::Beta: {
      auto ptr = reinterpret_cast<const Beta *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Discrete: {
      auto ptr = reinterpret_cast<const Discrete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Flip: {
      auto ptr = reinterpret_cast<const Flip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Gamma: {
      auto ptr = reinterpret_cast<const Gamma *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Laplace: {
      auto ptr = reinterpret_cast<const Laplace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Mixture: {
      auto ptr = reinterpret_cast<const Mixture *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::MultivariateNormal: {
      auto ptr = reinterpret_cast<const MultivariateNormal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Normal: {
      auto ptr = reinterpret_cast<const Normal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Poisson: {
      auto ptr = reinterpret_cast<const Poisson *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::Truncated: {
      auto ptr = reinterpret_cast<const Truncated *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::UniformContinuous: {
      auto ptr = reinterpret_cast<const UniformContinuous *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Distribution::UniformDiscrete: {
      auto ptr = reinterpret_cast<const UniformDiscrete *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyDistributionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyDistribution(
        verifier,  values->Get(i), types->GetEnum<Distribution>(i))) {
      return false;
    }
  }
  return true;
}

inline const protocol::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<protocol::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<protocol::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<protocol::Message> root) {
  fbb.Finish(root);
}

}  // namespace protocol

#endif  // FLATBUFFERS_GENERATED_INFCOMP_PROTOCOL_H_
